/* Apuntes del libro ‚ÄúLearning SQL, Second Edition, by Alan
Beaulieu. Copyright 2009 O‚ÄôReilly Media, Inc., 978-0-596-52083-0.‚Äù */

TIPOS DE TABLAS
1. Tablas Permanentes
- Son tablas que se crean expl√≠citamente en la base de datos.
- C√≥mo se crean: Usando la sentencia CREATE TABLE.

2. Tablas Temporales
- Son tablas que existen solo durante la ejecuci√≥n de una consulta. Se generan a partir de los resultados de una subconsulta (subquery).
- No se almacenan f√≠sicamente en la base de datos.
- Son visibles y se puede interactuar con ellas dentro de la consulta principal.

-- SELECT *
-- FROM (SELECT nombre, salario FROM empleados WHERE salario > 3000) AS temp_table;

 Tablas Virtuales (Vistas o Views)
- Son consultas almacenadas en el diccionario de datos de la base de datos.
- No almacenan datos f√≠sicamente, sino que se construyen din√°micamente al ser invocadas.
- Simplifican consultas complejas y mejoran la seguridad al restringir el acceso a los datos.
- C√≥mo se crean: Usando la sentencia CREATE VIEW.

-- CREATE VIEW vista_empleados AS
-- SELECT nombre, salario
-- FROM empleados
-- WHERE salario > 3000;

TABLAS GENERADAS CON SUBQUERIES
- Una subquery es una consulta contenida dentro de otra consulta.
- Se agrupan dentro de par√©ntesis.
- Pueden aparecer en diferentes partes de una consulta, como en SELECT, FROM, WHERE, etc.
- Su rol principal es generar una tabla temporal con la que se puede interactuar dentro de la consulta principal.

VISTAS O VIEWS
- Una vista es una consulta almacenada en el diccionario de datos de la base de datos.
- No almacena datos f√≠sicamente, sino que muestra los datos de las tablas subyacentes en tiempo real.
- Mejora la claridad y reutilizaci√≥n del c√≥digo.
- Puede usarse para restringir el acceso a ciertos datos.
- Las vistas se crean por diferentes motivos como ocultar columnas a los usuarios o simplificar dise√±os de base de datos complejos.

-- CREATE VIEW vista_empleados_departamentos AS
-- SELECT e.nombre AS empleado, d.nombre AS departamento
-- FROM empleados e
-- INNER JOIN departamentos d ON e.departamento_id = d.departamento_id;

WHERE
- Se usa como mecanismo de filtrado para devolver solo el result set que queremos.
Se pueden incluir tantas condiciones como sean necesarias y se separan con AND, OR y NOT.

- Combinaci√≥n de AND, OR y NOT
Puedes combinar estos operadores para crear condiciones m√°s complejas. Sin embargo, es importante usar par√©ntesis () para definir el orden de evaluaci√≥n de las condiciones, ya tienen mayor precedencia:
NOT tiene la mayor precedencia.
AND tiene mayor precedencia que OR.
Usa par√©ntesis () para evitar confusiones y asegurar el orden correcto de evaluaci√≥n.

GROUP BY
Sirve para encontrar tendencias. Se usa para agrupar informaci√≥n segun valores de columnas.

ORDER BY
La cl√°usula ORDER BY es el mecanismo para ordenar tu conjunto de resultados utilizando ya sea datos brutos de columnas o expresiones basadas en datos de columnas.

ORDER CON expresiones
Por ejemplo ordenar por los ultimos 3 digitos del fed_id:

-- SELECT cust_id, cust_type_cd, city, state, fed_id
--  -> FROM customer
--  -> ORDER BY RIGHT(fed_id, 3);

ORDER CON MARCADORES DE POSICI√ìN NUMERICOS
Por ejemplo, si queres ordenar por la segunda y quinta columna: 

-- SELECT emp_id, title, start_date, fname, lname
--  -> FROM employee
--  -> ORDER BY 2, 5;

Podr√≠as querer usar esta funci√≥n con moderaci√≥n, ya que agregar una columna a la cl√°usula SELECT sin cambiar los n√∫meros en la cl√°usula ORDER BY puede llevar a resultados inesperados. Personalmente, podr√≠a referenciar columnas por posici√≥n al escribir consultas ad hoc, pero siempre referencio columnas por nombre al escribir c√≥digo.

****    EJERCICIOS    *****
3-1
Retrieve the employee ID, first name, and last name for all bank employees. Sort by last
name and then by first name.
SELECT 
    emp_id,
    fname,
    lname
FROM employee 
ORDER BY lname, fname;

3-2
Retrieve the account ID, customer ID, and available balance for all accounts whose
status equals 'ACTIVE' and whose available balance is greater than $2,500.

SELECT 
    account_id,
    cust_id,
    avail_balance
FROM account 
WHERE status = 'ACTIVE'
    AND avail_balance > 2500;

3-3
Write a query against the account table that returns the IDs of the employees who
opened the accounts (use the account.open_emp_id column). Include a single row for
each distinct employee.

SELECT DISTINCT
    open_emp_id
FROM account;

3-4
Fill in the blanks (denoted by <#>) for this multi-data-set query to achieve the results
shown here:

 SELECT p.product_cd, a.cust_id, a.avail_balance
 -> FROM product p INNER JOIN account a
 -> ON p.product_cd = a.product_cd
 -> WHERE product_type_cd = 'ACCOUNT';

 --

 ----------- FILTROS ---> WHERE -----------

 Condiciones de Equidad:
 WHERE title = 'Teller';

Condiciones de Inequidad:
Se usa con los operadores  != o <> 
WHERE pt.name <> 'Customer Accounts';

Condiciones de rango:
WHERE start_date < '2007-01-01';

Operador BETWEEN
Cuando tenes un limite an dos intancias diferentes.
Siempre debes especificar primero el l√≠mite inferior del rango (despu√©s de BETWEEN) y luego el l√≠mite superior (despu√©s de AND).
Ambos limites son inclusivos.
WHERE start_date BETWEEN '2005-01-01' AND '2007-01-01';

Tambi√©n se pueden usar rangos con cadenas:
WHERE cust_type_cd = 'I'
 -> AND fed_id BETWEEN '500-00-0000' AND '999-99-9999';

Cuando tenemos un grupo de valores individuales usamos IN, no importa la cantidad de valores que haya:
WHERE product_cd IN ('CHK','SAV','CD','MM');

SUBQUERIES CON WHERE
Adem√°s de escribir tu propio conjunto de expresiones, como ('CHK', 'SAV', 'CD', 'MM'), puedes usar una subconsulta para generar un conjunto sobre la marcha.

Por ejemplo, los cuatro tipos de productos utilizados en la consulta anterior tienen un product_type_cd de 'ACCOUNT', as√≠ que ¬øpor qu√© no usar una subconsulta en la tabla de productos para recuperar los cuatro c√≥digos de producto en lugar de nombrarlos expl√≠citamente?
WHERE product_cd IN (SELECT product_cd FROM product
 -> WHERE product_type_cd = 'ACCOUNT');

NOT IN
Se usa para verificar que una expresion no existe.
WHERE product_cd NOT IN ('CHK','SAV','CD','MM');

Condiciones de Coincidencia
Por ejemplo, si queres buscar los empleados que empiezan con T.
WHERE LEFT(lname, 1) = 'T';
De todas formas, con LEFT no tenemos mucha flexibilidad.

Por eso, tambi√©n podemos usar caracteres comod√≠n.
Al buscar coincidencias parciales en cadenas, podr√≠as estar interesado en:

Cadenas que comienzan o terminan con un determinado car√°cter.
Cadenas que comienzan o terminan con una subcadena espec√≠fica.
Cadenas que contienen un determinado car√°cter en cualquier posici√≥n.
Cadenas que contienen una subcadena en cualquier parte de la cadena.
Cadenas con un formato espec√≠fico, sin importar los caracteres individuales
% se usa para cualquier n√∫mero de caracteres 
_ se usa para exactamente un caracter.
WHERE lname LIKE '_a%e%';
WHERE fed_id LIKE '___-__-____';
 WHERE lname LIKE 'F%' OR lname LIKE 'G%';


EXPRESIONES REGULARES
Incluso m√°s flexibilidad que los comodines.
Este filtro es igual al anterior pero con regexp:
WHERE lname REGEXP '^[FG]';


NULL
Casos en los que un valor puede estar ausente en una base de datos:
No aplicable

Cuando un campo no es relevante en un contexto espec√≠fico.
üìå Ejemplo: El ID del empleado en una transacci√≥n realizada en un cajero autom√°tico (ATM), donde no hay un empleado involucrado.
Valor a√∫n no conocido

Cuando un dato no est√° disponible en el momento de la creaci√≥n del registro.
üìå Ejemplo: El ID fiscal federal de un cliente cuando se crea su cuenta, pero a√∫n no ha sido proporcionado.
Valor indefinido

Cuando un dato depende de otra informaci√≥n que a√∫n no existe en la base de datos.
üìå Ejemplo: Se crea una cuenta para un producto que todav√≠a no ha sido agregado a la base de datos.